% ========================================================
% 矢印の頭のＶ字の描画（三次元グラフ用。
% 　　　　　　　　　　　１コマンドで処理できるＶ字は１つのみ）
function [h_arw]=plot_arrow3d(xyz1,xyz2,ang,leng,nor,rad,rev)

  % 【入力】
  % 　　xyz1   :　主軸上に存在する任意の１点のx,y,z座標
  % 　　　　　　　　　　　　　　　　　 （３要素の行ベクトル）
  % 　　xyz2   :　矢印の先端のx,y,z座標（３要素の行ベクトル）
  % 　　ang    :　Ｖ字の両翼間の角度[度]
  % 　　leng   :　Ｖ字の両翼の長さ
  % 　　nor    :　Ｖ字描画面の法線のx,y,z座標（３要素の行ベクトル）
  % 【入力(任意)】
  % 　　rad    :　主軸の曲率半径
  % 　　　　　　　　　　（+/- : 法線側から見て左/右へ曲がるカーブ）
  % 　　rev    :　Ｖ字中心線の傾き角度の補正量[度]（rev>0）
  % 【出力】
  % 　　h_arw  :　描かれたＶ字図形のハンドル

  ang=ang*pi/180;

  nor_a=(xyz2-xyz1)/norm(xyz2-xyz1);   % 主軸方向の単位ベクトル

  % ===================
  % 回転前のＶ字の原図（xy面上で先端を[0 0]に置いてy軸の正方向向き）
  if nargin>=6       % 曲率半径 rad の入力があったときの処理。
    if nargin==7     % さらに、Ｖ字の傾き角度の補正を指示されたとき。
      threv=sign(rad)*rev*pi/180;
    else
      threv=0;
    end
    th0=sign(rad)*pi/2+pi/2+threv;
    R=abs(rad);
    cen1=R*[cos(th0-ang/2) sin(th0-ang/2)];      % 円弧１の中心座標
    cen2=R*[cos(th0+ang/2) sin(th0+ang/2)];      % 円弧２の中心座標
    th=linspace(0,leng/rad,5);                   % 弧長バラメータ/半径
    x1=R*cos(-pi+th0-ang/2-fliplr(th))+cen1(1);  % 円弧１の折線座標
    y1=R*sin(-pi+th0-ang/2-fliplr(th))+cen1(2);
    x2=R*cos(-pi+th0+ang/2-th)+cen2(1);          % 円弧２の折線座標
    y2=R*sin(-pi+th0+ang/2-th)+cen2(2);
    x=[x1 x2]; y=[y1 y2]; z=x*0;
  else             % 曲率半径 rad の入力が無いときの処理
    x=[-1 0 1]*leng*sin(ang/2);
    y=-[1 0 1]*leng*cos(ang/2);
    z=x*0;
  end
  nor_z=[0 0 1];  % Ｖ字の原図面の法線 [0 0 1]

  % ===================
  % １回目の回転

  if norm(nor_z-nor)<1e-6    % 【両法線ベクトルが殆ど一致しているとき】
    p2=[x;y;z]';                % 点群を縦方向に並べ替え
    nor_t=[0 1 0];              % Ｖ字の主軸方向のベクトル（+y方向）
  elseif norm(nor_z+nor)<1e-6   % 【両法線ベクトルが逆向きで殆ど相殺】
    p2=[x;-y;z]';               % yだけを反転し点群を縦方向に並べ替え
    nor_t=[0 -1 0];             % Ｖ字の主軸方向のベクトル（-y方向）
  else                       % 【両法線ベクトル間に有意差があるとき】
    % 法線 nor_z を指定法線 nor に一致させるための回転中心軸と
    % 　　　　　回転角度を求める。スカラー積(sp)の正負で処理を分ける。
    sp=dot(nor_z,nor);          % 両ベクトルの角度差が90°以下で正。
    if sp>=0     % 90°以下
      axrot=cross(nor_z,nor);   % 両者の外積をとり、回転中心軸を得る。
      angrot=asin(norm(axrot));      % 一致させるために回転すべき角度。
    else         % 90°超
      axrot=cross(nor_z,-nor);  % 回転中心軸をsp>=0のときとは逆向きに。
      angrot=asin(norm(axrot))+pi;   % 一致させるために回転すべき角度。
    end
    % Ｖ字の原図を回転（主軸上の情報も１点だけ付加）
    p2=rot_points_3d([0 0 0],axrot,[[0 -1 0];[x;y;z]'],angrot);
    nor_t=[0 0 0]-p2(1,:);      % 回転後のＶ字の主軸方向のベクトル
    nor_t=nor_t/norm(nor_t) ;   % 同上の単位ベクトル化
    p2(1,:)=[];                 % 用済みの付加主軸情報を削除
  end

  % ===================
  % ２回目の回転

  % nor_a ベクトルの【１回目の回転後の描画面】への投影ベクトルを
  % 　単位化したベクトル nor_b を求める。
  % ローカル関数の呼び出し
  [x2,y2,z2,~]=intsec_Plane_and_PerpLine(nor(1),nor(2),nor(3),0, ...
                                         nor_a(1),nor_a(2),nor_a(3));
  nor_b=[x2 y2 z2]/norm([x2 y2 z2]);

  if norm(nor_t-nor_b)<1e-6    % 【両主軸方向単位ベクトルが殆ど一致】
    p2=p2;    % 何もせず
  elseif norm(nor_t+nor_b)<1e-6    % 【両主軸方向単位ベクトルが
                                                 % 逆向きで殆ど相殺】
    p2=-p2;   % ベクトルを反転
  else               % 【両主軸方向単位ベクトル間に有意差があるとき】
    % nor_t をnor_b に一致させるための回転中心軸と回転角度を
    % 　求める。スカラー積(sp)の正負で処理を分ける。
    sp=dot(nor_t,nor_b);         % 両ベクトルの角度差が90°以下で正。
    if sp>=0     % 90°以下
      axrot=cross(nor_t,nor_b);  % 両者の外積をとり、回転中心軸を得る。
      angrot=asin(norm(axrot));  % 一致させるために回転すべき角度。
    else         % 90°超
      axrot=cross(nor_t,-nor_b); % 回転中心軸をsp>=0のときとは逆向きに。
      angrot=asin(norm(axrot))+pi;   % 一致させるために回転すべき角度。
    end

    p2=rot_points_3d([0 0 0],axrot,p2,angrot);
  end

  p2=p2+xyz2;                   % Ｖ字の頂点を指定点まで平行移動

  % Ｖ字の描画
  h_arw=plot3(p2(:,1),p2(:,2),p2(:,3),'k');
end
% ========================================================
% ========================================================
% 多点群を一括して三次元回転させる関数

function [p2]=rot_points_3d(v00,v0,p1,ang)

  %【入力】
  % v00:  回転軸ベクトルの始点の座標（１行３列の行ベクトル）
  % v0:   回転軸ベクトルの向き
  %       　（１行３列の行ベクトル。単位化されていなくても可）
  % p1:   回転される前の点群の座標（多行３列の行列）
  % ang:  回転角[rad]（ v0の右ねじ方向が正。スカラー）
  % 
  %【出力】
  % p2:   回転された後の点群の座標（多行３列の行列）

  p1t=p1';         % 点群の座標を転置して３行多列化。
  nn=v0/norm(v0);  % 回転軸ベクトルの単位化
  n1=nn(1); n2=nn(2); n3=nn(3);  % 回転軸ベクトルのx,y,z成分
  sa=sin(ang);
  ca=cos(ang);
  ca1=1-ca;        % 1-cos(ang)
  % ロドリゲスの三次元回転行列
  R=[n1^2*ca1+ca       n1*n2*ca1-n3*sa  n3*n1*ca1+n2*sa
     n1*n2*ca1+n3*sa   n2^2*ca1+ca      n2*n3*ca1-n1*sa
     n3*n1*ca1-n2*sa   n2*n3*ca1+n1*sa  n3^2*ca1+ca    ];
  p1t=p1t-v00';    % 回転ベクトルの始点が原点に来るように、
                   % 　座標全体を平行移動する。
  p2t=R*p1t;       % v0を中心軸にして点群を回転させる。
  p2t=p2t+v00';    % 回転前に行った平行移動を元に戻す。
  p2=p2t';         % 転置して多行３列化したうえ、最終出力とする。
end

% ========================================================
% ========================================================
% axes の座標値を figure の normalized 単位に変換するローカル関数

function [x1_2,y1_2]=axe2fig(haxe,x1x2,y1y2)
  % 【入力】
  % 　haxe:　現在アクティブになっている axes のハンドル。
  % 　　　　 呼び出し側での引数は「gca」とすること。
  % 　x1x2:　axes 上の点の x座標群（点の数に相当する要素数の行ベクトル）
  % 　y1y2:　　　〃　　　　y　　　　　　　　　　　〃
  % 【出力】
  % 　x1_2:　x1x2 を normalized 単位に変換後の行ベクトル
  % 　y1_2:　y1y2　　　　　　　　　　〃

  ap=haxe.Position;
  al=ap(1); ab=ap(2); aw=ap(3); ah=ap(4);
  area=axis(haxe);
  xmin=area(1); xmax=area(2); ymin=area(3); ymax=area(4);
  x1_2=aw*(x1x2-xmin)/(xmax-xmin)+al;
  y1_2=ah*(y1y2-ymin)/(ymax-ymin)+ab;
end

% ========================================================
% ========================================================
% ３点の座標から それらを含む平面の式の係数を求めるローカル関数

function [a,b,c,d]=find_plane_const(xyz1,xyz2,xyz3)
  % 【入力】
  % 　xyz1,xyz2,xyz3:
  % 　　　　 ３点の座標 [x1 y1 z1],[x2 y2 z2],[x3 y3 z3]。
  % 　　　　 ３点は一直線上に並んでいないこと。
  % 【出力】
  % 　a,b,c,d:
  % 　　　　 平面の式 ax + by + cz + d = 0 の係数。
  % 　　　　 [a b c] が法線の単位ベクトルになるように正規化済。
  % 　　　　 ただし、逆向きの -[a b c] も同じく法線。意図に応じて
  % 　　　　 適切な方を選択。

  p2=xyz2-xyz1; p3=xyz3-xyz1;
  norx=cross(p2,p3);
  nor=norx/norm(norx);
  a=nor(1); b=nor(2); c=nor(3); 
  d=-dot(nor,xyz1);
end

% ========================================================
% ========================================================
% 【任意の点】から【任意の平面】への垂線が、その平面と交わる点の座標

function [x2,y2,z2,L]=intsec_Plane_and_PerpLine(a,b,c,d,x1,y1,z1)
  % 【入力】
  % 　a,b,c,d: 　平面の式 ax + by + cz + d = 0 の係数。
  % 　　　　　 　　正規化前の平面の法線は [a b c] と解釈される。
  % 　x1,y1,z1:　任意の点の座標
  % 【出力】
  % 　x2,y2,z2:　平面上にできた交点の座標
  % 　L:       　垂線の長さ（法線側のとき +、反対側のとき -）

  % 平面の式の係数の正規化
  U=[a b c d]/norm([a b c]);
  a=U(1); b=U(2); c=U(3); d=U(4); 
  % 交点の計算
  M=[1 0 0 a
     0 1 0 b
     0 0 1 c
     a b c 0];
  V=inv(M)*[x1 y1 z1 -d]';
  x2=V(1); y2=V(2); z2=V(3); L=V(4); 
end
